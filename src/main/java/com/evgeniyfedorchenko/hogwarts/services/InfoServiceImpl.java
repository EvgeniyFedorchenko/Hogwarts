package com.evgeniyfedorchenko.hogwarts.services;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class InfoServiceImpl implements InfoService {

    @Value("${server.port}")
    private int port;

    @Override
    public Integer getUsedPort() {
        return port;
    }

    @Override
    public long optimizeAlgorithm() {

        long n = 1_000_000;
        return n * (n + 1) / 2;

        /*    ПРОЧТИТЕ ЭТО ПОЖАЛУЙСТА

          Исходный алгоритм:

              int sum = Stream.iterate(1, a -> a + 1)
                     .limit(1_000_000)
                     .reduce(0, (a, b) -> a + b);

          У меня на компе он выполняется за 42 миллисекунд в среднем (замерял при помощи System.currentTimeMillis()),
          но в нем есть явные проблемы, связанные с переполнением типа данных int. При этом недостаточно просто сменить
          тип данных у переменной 'sum' на long, так как переполнение происходит еще в функции .reduce(),
          тк она накапливает значение в переменной типа Integer. В итоге ответ получается 1_784_293_664, что неверно

          Предложенное мной решение не имеет таких проблем
          и корректно считает сумму первых 1_000_000 целых положительных чисел, получая 500_000_500_000.
          Оно выполняется у меня на компе стабильно за ноль миллисекунд!
          При том это ДЕЙСТВИТЕЛЬНО верный ответ (я это проверил).
          Но если стримы использовать обязательно (о чем в задании не сказано),
          то я могу предложить еще вот такое решение:

              int sum = IntStream.rangeClosed(1, 1_000_000).sum();

          Это решение имеет ровно те же особенности, что и алгоритм из задания и сохраняет в переменную
          ровно то же самое число (1_784_293_664), что и исходный алгоритм из задания.
          Но выполняется в среднем за 6 миллисекунд у меня на компе, то есть в 8 раз быстрее

          Спасибо!

        */
    }
}
